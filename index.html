<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avaruusalus Väistelypeli</title>
    <style>
        body { margin: 0; overflow: hidden; text-align: center; }
        canvas { background: black; display: block; margin: auto; }
        #score {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 20px;
            font-family: Arial, sans-serif;
        }
        #restartButton {
            margin-top: 10px;
            padding: 10px;
            font-size: 20px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #restartButton:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Pisteet: 0</div>
    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const scoreDisplay = document.getElementById("score");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Ladataan kuvat
        const images = {
            ship: new Image(),
            bullet: new Image(),
            basicUfo: new Image(),
            followUfo: new Image(),
            splitUfo: new Image(),
            background: new Image()
        };
        images.ship.src = "alus.png"; // Paikallinen tiedosto
        images.bullet.src = "rockets_PNG13272.png"; // Paikallinen tiedosto
        images.basicUfo.src = "ufo.png"; // Paikallinen tiedosto
        images.followUfo.src = "ufo2.png"; // Paikallinen tiedosto
        images.splitUfo.src = "ufo3.png"; // Paikallinen tiedosto
        images.background.src = "skynews-planet-earth-sun_6072586.jpg"; // Paikallinen tiedosto

        let ship, obstacles, bullets, basicUfo, followUfo, splitUfos, keys, obstacleSpeed, canShoot, score, scoreInterval;

        function init() {
            ship = { x: 150, y: canvas.height / 2, width: 100, height: 100, speed: 5, alive: true };
            obstacles = [];
            bullets = [];
            followUfo = null;
            splitUfos = [];
            keys = {};
            obstacleSpeed = 5;
            canShoot = true;
            score = 0;
            scoreDisplay.textContent = "Pisteet: 0";

            clearInterval(scoreInterval);
            scoreInterval = setInterval(() => {
                if (ship.alive) {
                    score += 1;
                    scoreDisplay.textContent = "Pisteet: " + score;
                }
            }, 1000);

            // Lisätty esteiden luontiväli
            setInterval(() => {
                const size = Math.random() * 100 + 20; // Satunnainen koko 20 - 120 välillä
                const hits = Math.ceil(size / 20); // Osumien määrä suhteessa kokoon
                obstacles.push({
                    x: canvas.width,
                    y: Math.random() * (canvas.height - size),
                    width: size,
                    height: size,
                    hits: hits
                });
            }, 1000);

            // Lisätty seuraavan UFO:n luontiväli
            setInterval(() => {
                if (!followUfo) {
                    const size = Math.random() * 100 + 20; // Satunnainen koko 20 - 120 välillä
                    const hits = Math.ceil(size / 20) * 2; // Kaksi kertaa enemmän osumia
                    followUfo = {
                        x: canvas.width,
                        y: Math.random() * (canvas.height - size),
                        width: size,
                        height: size,
                        hits: hits
                    };
                }
            }, 10000);

            // Lisätty nopean UFO:n luontiväli
            setInterval(() => {
                const size = Math.random() * 100 + 20; // Satunnainen koko 20 - 120 välillä
                const hits = Math.ceil(size / 20); // Osumien määrä suhteessa kokoon
                splitUfos.push({
                    x: canvas.width,
                    y: Math.random() * (canvas.height - size),
                    width: size,
                    height: size,
                    hits: hits,
                    speed: obstacleSpeed // Sama nopeus kuin esteellä
                });
            }, 5000); // Useammin kuin ennen
        }

        window.addEventListener("keydown", (e) => {
            keys[e.key] = true;
            if (e.key === " " && canShoot) {
                shoot();
                canShoot = false;
            }
        });

        window.addEventListener("keyup", (e) => {
            keys[e.key] = false;
            if (e.key === " ") canShoot = true;
        });

        function shoot() {
            bullets.push({
                x: ship.x + ship.width,
                y: ship.y + ship.height / 2 - 5,
                width: 10,
                height: 10,
                speed: 7
            });
        }

        // Törmäystunnistus ympyrän avulla
        function checkCircleCollision(circle1, circle2) {
            const dx = circle1.x - circle2.x;
            const dy = circle1.y - circle2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            return distance < (circle1.radius + circle2.radius);
        }

        function update() {
            if (keys["ArrowUp"] && ship.y > 0) ship.y -= ship.speed;
            if (keys["ArrowDown"] && ship.y + ship.height < canvas.height) ship.y += ship.speed;
            if (keys["ArrowLeft"] && ship.x > 0) ship.x -= ship.speed;
            if (keys["ArrowRight"] && ship.x + ship.width < canvas.width) ship.x += ship.speed;

            bullets.forEach((bullet, index) => {
                bullet.x += bullet.speed;
                if (bullet.x > canvas.width) bullets.splice(index, 1);
            });

            obstacles.forEach((ob, index) => {
                ob.x -= obstacleSpeed;
                if (ob.x + ob.width < 0) obstacles.splice(index, 1);

                bullets.forEach((bullet, bulletIndex) => {
                    if (checkCircleCollision({
                        x: bullet.x + bullet.width / 2,
                        y: bullet.y + bullet.height / 2,
                        radius: bullet.width / 2
                    }, {
                        x: ob.x + ob.width / 2,
                        y: ob.y + ob.height / 2,
                        radius: ob.width / 2
                    })) {
                        bullets.splice(bulletIndex, 1);
                        ob.hits--;
                        ob.width -= ob.width / (ob.hits + 1); // Pienennä leveys suhteessa jäljellä oleviin osumiin
                        ob.height -= ob.height / (ob.hits + 1); // Pienennä korkeus suhteessa jäljellä oleviin osumiin
                        if (ob.hits <= 0) {
                            obstacles.splice(index, 1);
                            score += 5;
                            scoreDisplay.textContent = "Pisteet: " + score;
                        }
                    }
                });

                if (ob.hits > 0 && checkCircleCollision({
                    x: ship.x + ship.width / 2,
                    y: ship.y + ship.height / 2,
                    radius: ship.width / 2
                }, {
                    x: ob.x + ob.width / 2,
                    y: ob.y + ob.height / 2,
                    radius: ob.width / 2
                })) {
                    ship.alive = false;
                }
            });

            if (followUfo) {
                let dx = ship.x - followUfo.x;
                let dy = ship.y - followUfo.y;
                let dist = Math.sqrt(dx * dx + dy * dy);

                followUfo.x += (dx / dist);
                followUfo.y += (dy / dist);

                bullets.forEach((bullet, bulletIndex) => {
                    if (followUfo && checkCircleCollision({
                        x: bullet.x + bullet.width / 2,
                        y: bullet.y + bullet.height / 2,
                        radius: bullet.width / 2
                    }, {
                        x: followUfo.x + followUfo.width / 2,
                        y: followUfo.y + followUfo.height / 2,
                        radius: followUfo.width / 2
                    })) {
                        bullets.splice(bulletIndex, 1);
                        followUfo.hits--;
                        followUfo.width -= followUfo.width / (followUfo.hits + 1); // Pienennä leveys suhteessa jäljellä oleviin osumiin
                        followUfo.height -= followUfo.height / (followUfo.hits + 1); // Pienennä korkeus suhteessa jäljellä oleviin osumiin
                        if (followUfo.hits <= 0) {
                            followUfo = null;
                            score += 10;
                            scoreDisplay.textContent = "Pisteet: " + score;
                        }
                    }
                });

                if (followUfo && followUfo.hits > 0 && checkCircleCollision({
                    x: ship.x + ship.width / 2,
                    y: ship.y + ship.height / 2,
                    radius: ship.width / 2
                }, {
                    x: followUfo.x + followUfo.width / 2,
                    y: followUfo.y + followUfo.height / 2,
                    radius: followUfo.width / 2
                })) {
                    ship.alive = false;
                }
            }

            splitUfos.forEach((splitUfo, index) => {
                splitUfo.x -= splitUfo.speed;
                if (splitUfo.x + splitUfo.width < 0) {
                    splitUfos.splice(index, 1);
                } else {
                    bullets.forEach((bullet, bulletIndex) => {
                        if (splitUfo && checkCircleCollision({
                            x: bullet.x + bullet.width / 2,
                            y: bullet.y + bullet.height / 2,
                            radius: bullet.width / 2
                        }, {
                            x: splitUfo.x + splitUfo.width / 2,
                            y: splitUfo.y + splitUfo.height / 2,
                            radius: splitUfo.width / 2
                        })) {
                            bullets.splice(bulletIndex, 1);
                            splitUfo.hits--;
                            splitUfo.width -= splitUfo.width / (splitUfo.hits + 1); // Pienennä leveys suhteessa jäljellä oleviin osumiin
                            splitUfo.height -= splitUfo.height / (splitUfo.hits + 1); // Pienennä korkeus suhteessa jäljellä oleviin osumiin
                            if (splitUfo.hits <= 0) {
                                // Halkeaminen kahtia osumasta
                                const newSize = splitUfo.width / 2;
                                if (newSize > 10) {
                                    splitUfos.push({
                                        x: splitUfo.x,
                                        y: splitUfo.y,
                                        width: newSize,
                                        height: newSize,
                                        hits: Math.ceil(newSize / 20),
                                        speed: splitUfo.speed
                                    });
                                    splitUfos.push({
                                        x: splitUfo.x,
                                        y: splitUfo.y + newSize,
                                        width: newSize,
                                        height: newSize,
                                        hits: Math.ceil(newSize / 20),
                                        speed: splitUfo.speed
                                    });
                                }
                                splitUfos.splice(index, 1);
                                score += 20;
                                scoreDisplay.textContent = "Pisteet: " + score;
                            }
                        }
                    });

                    if (splitUfo && splitUfo.hits > 0 && checkCircleCollision({
                        x: ship.x + ship.width / 2,
                        y: ship.y + ship.height / 2,
                        radius: ship.width / 2
                    }, {
                        x: splitUfo.x + splitUfo.width / 2,
                        y: splitUfo.y + splitUfo.height / 2,
                        radius: splitUfo.width / 2
                    })) {
                        ship.alive = false;
                    }
                }
            });
        }

        function draw() {
            ctx.drawImage(images.background, 0, 0, canvas.width, canvas.height);
            ctx.drawImage(images.ship, ship.x, ship.y, ship.width, ship.height);

            bullets.forEach(bullet => {
                ctx.drawImage(images.bullet, bullet.x, bullet.y, bullet.width, bullet.height);
            });

            obstacles.forEach(ob => {
                if (ob.hits > 0) {
                    ctx.drawImage(images.basicUfo, ob.x, ob.y, ob.width, ob.height);
                }
            });

            if (followUfo && followUfo.hits > 0) {
                ctx.drawImage(images.followUfo, followUfo.x, followUfo.y, followUfo.width, followUfo.height);
            }

            splitUfos.forEach(splitUfo => {
                if (splitUfo.hits > 0) {
                    ctx.drawImage(images.splitUfo, splitUfo.x, splitUfo.y, splitUfo.width, splitUfo.height);
                }
            });
        }

        function gameLoop() {
            if (ship.alive) {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            } else {
                clearInterval(scoreInterval);
                ctx.fillStyle = "white";
                ctx.font = "30px Arial";
                ctx.fillText("Game Over", canvas.width / 2 - 80, canvas.height / 2);
                ctx.fillText("Pisteet: " + score, canvas.width / 2 - 80, canvas.height / 2 + 30);
                const restartButton = document.createElement("button");
                restartButton.textContent = "Uudelleen";
                restartButton.id = "restartButton";
                document.body.appendChild(restartButton);
                restartButton.addEventListener("click", () => {
                    document.body.removeChild(restartButton);
                    init();
                    gameLoop();
                });
            }
        }

        init();
        gameLoop();
    </script>
</body>
</html>
