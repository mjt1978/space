<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Crush</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background-color: black;
        }

        #parallaxContainer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    z-index: -1;
}

.layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 200%; /* tarvitaan toistumiseen */
    height: 100%;
    background-repeat: repeat-x;
    background-size: auto 100%;
    will-change: background-position;
    pointer-events: none;
}

#backgroundLayer1 {
    background-image: url('background4.png'); /* kaukainen t√§htitausta */
    z-index: 1;
}

#backgroundLayer2 {
    background-image: url('background5.png'); /* keskitaso, esim. sumu tai planeettoja */
    z-index: 2;
}

#backgroundLayer3 {
    background-image: url('background6.png'); /* l√§hin, esim. maapinta ja r√§j√§hdyksi√§ */
    z-index: 3;
}


        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('startimage.png');
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            background-color: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            z-index: 10;
        }

        #startScreen h1 {
            font-size: 5vw;
            margin-bottom: 4vh;
            text-shadow: 0 0 10px rgba(0, 0, 0, 0.7);
        }

        #startScreen button {
            font-size: 2vw;
            padding: 1.5vh 3vw;
            margin: 1vh;
            cursor: pointer;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid white;
            border-radius: 5px;
            transition: all 0.3s;
            min-width: 200px;
        }

        #startScreen button:hover {
            background-color: rgba(255, 255, 255, 0.7);
            color: black;
        }

                canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #energyBar {
            position: absolute;
            top: 1vh;
            left: 1vw;
            width: 200px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            border-radius: 5px;
            overflow: hidden;
        }

        #energyFill {
            height: 100%;
            width: 100%;
            background-color: #00ff00;
            transition: width 0.3s, background-color 0.3s;
        }

        #livesContainer {
            position: absolute;
            top: 4vh;
            left: 1vw;
            display: flex;
            gap: 10px;
        }

        .life {
            width: 30px;
            height: 30px;
            background-image: url('alus.png');
            background-size: contain;
            background-repeat: no-repeat;
            transition: all 0.3s;
        }

        #waveInfo {
            position: absolute;
            top: 1vh;
            right: 1vw;
            color: white;
            font-size: 2vw;
            text-shadow: 0 0 5px black;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }

        #gameOver,
        #levelCompleted {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 3vh 3vw;
            border-radius: 10px;
            border: 2px solid white;
            width: 80%;
            max-width: 500px;
        }

        #gameOver h1,
        #levelCompleted h1 {
            font-size: 4vw;
            color: red;
            margin: 0 0 2vh 0;
            text-shadow: 0 0 5px white;
        }

        #gameOver button,
        #levelCompleted button {
            font-size: 2vw;
            padding: 1vh 2vw;
            margin-top: 2vh;
            cursor: pointer;
            background-color: rgba(255, 255, 255, 0.8);
            border: none;
            border-radius: 5px;
            transition: all 0.3s;
        }

        #gameOver button:hover,
        #levelCompleted button:hover {
            background-color: white;
        }

        @media (max-width: 768px) {
            #startScreen h1 {
                font-size: 8vw;
            }
            
            #startScreen button {
                font-size: 4vw;
                padding: 1.5vh 3vw;
            }
            
            #gameOver h1,
            #levelCompleted h1 {
                font-size: 6vw;
            }
            
            #gameOver button,
            #levelCompleted button {
                font-size: 4vw;
            }
            
            #energyBar {
                width: 150px;
                height: 15px;
            }
            
            #waveInfo {
                font-size: 4vw;
            }
            
            #livesContainer {
                top: 3.5vh;
            }
            
            .life {
                width: 20px;
                height: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <div id="levelButtons"></div>
    </div>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="energyBar">
            <div id="energyFill"></div>
        </div>
        <div id="livesContainer"></div>
        <div id="waveInfo">Aalto: 1/5</div>
        <div id="gameOver">
            <h1>Game Over</h1>
            <button onclick="restartGame()">Uusi yritys</button>
        </div>
        <div id="levelCompleted">
            <h1>Taso Suoritettu!</h1>
            <button onclick="nextLevel()">Seuraava taso</button>
        </div>
    </div>

<div id="parallaxContainer">
    <div class="layer" id="backgroundLayer1"></div> <!-- kaukaisin -->
    <div class="layer" id="backgroundLayer2"></div> <!-- keskitason -->
    <div class="layer" id="backgroundLayer3"></div> <!-- l√§hin -->
</div>

    <script>
    
class SoundPool {
    constructor(src, poolSize = 5, volume = 1.0) {
        this.pool = [];
        this.index = 0;
        this.volume = volume;

        for (let i = 0; i < poolSize; i++) {
            const audio = new Audio(src);
            audio.volume = volume;
            this.pool.push(audio);
        }
    }

    play() {
        const sound = this.pool[this.index];
        sound.currentTime = 0;
        sound.play();
        this.index = (this.index + 1) % this.pool.length;
    }

    setVolume(volume) {
        this.volume = volume;
        this.pool.forEach(audio => audio.volume = volume);
    }

    load() {
        this.pool.forEach(audio => audio.load());
    }
}

// üéõÔ∏è Konfiguraatio kaikille √§√§nille
const soundConfig = {
    playerShoot: { src: 'blast_ship.mp3', volume: 0.3 },
    enemyShoot: { src: 'blast_ufo.mp3', volume: 0.3 },
    playerExplosion: { src: 'explosion_ship.mp3', volume: 0.9 },
    enemyExplosion: { src: 'explosion_ufo.mp3', volume: 0.8 },
    ufoSplit: { src: 'split.mp3', volume: 0.8 },
    collision: { src: 'collision.mp3', volume: 0.7 },
    meteorSound: { src: 'meteor.mp3', volume: 0.8 },
    powerup: { src: 'powerup.mp3', volume: 0.8 },
    // Lis√§√§ tarvittaessa
};

// üé∂ Alustetaan kaikki √§√§net yhdell√§ funktiolla
function initSoundEffects(config) {
    const sounds = {};

    for (const [key, { src, volume }] of Object.entries(config)) {
        const pool = new SoundPool(src, 5, volume);
        pool.load();
        sounds[key] = pool;
    }

    // Taustamusiikki erikseen
    const bgMusic = new Audio('music.mp3');
    bgMusic.volume = 0.2;
    bgMusic.loop = true;
    bgMusic.load();

    sounds.backgroundMusic = bgMusic;
    return sounds;
}

// üì¶ Luo kaikki √§√§net
const soundEffects = initSoundEffects(soundConfig);


        // Pelin asetukset
        const GAME_CONFIG = {
            playerSpeed: 7,
            bulletSpeed: 10,
            playerSize: { width: 150, height: 150 },
            playerEnergy: 5,
            playerLives: 3,
            enemySizes: {
                small: { width: 100, height: 100 },
                medium: { width: 150, height: 150 },
                large: { width: 200, height: 200 },
                xlarge: { width: 400, height: 400 }
            },
            collisionEllipse: {
                widthRatio: 1,
                heightRatio: 1
            },
            wavesPerLevel: 5,
            meteor: {
                minSpeed: 8,
                maxSpeed: 15,
                spawnInterval: { min: 300, max: 1000 },
                minSize: 60,
                maxSize: 200
            },
            powerup: {
                speed: 15,
                spawnChance: 0.01,  // 1% chance per frame
                spawnInterval: 300,  // Minimum frames between spawn attempts
                size: { width: 100, height: 100 }
            }
        };

        // Tasot
const LEVELS = [
    {
        id: 1,
        name: "Helppo",
        description: "Tuhotaan UFOja aaltoina!",
        waves: [
            {
                enemies: [
                    {
                        type: "medium",
                        count: 2,
                        health: 6,
                        speed: 3,
                        fireCooldown: 90,
                        bulletSpeed: 4,
                        bulletDamage: 1,
                        image: 'ufo4.png',
                        isSplitting: false,
                        requiredKills: 2,
                        collisionDamage: 2
                        rotationSpeed: 0.02
                    }
                ]
            },
            {
                enemies: [
                    {
                        type: "medium",
                        count: 3,
                        health: 6,
                        speed: 3,
                        fireCooldown: 90,
                        bulletSpeed: 4,
                        bulletDamage: 1,
                        image: 'ufo2.png',
                        isSplitting: false,
                        requiredKills: 3,
                        collisionDamage: 2
                        rotationSpeed: 0.02
                    }
                ]
            },
            {
                enemies: [
                    {
                        type: "xlarge",
                        count: 1,
                        health: 12,
                        speed: 2,
                        fireCooldown: 120,
                        bulletSpeed: 10,
                        bulletDamage: 1,
                        image: 'ufo5.png',
                        isSplitting: true,
                        requiredKills: 2,
                        collisionDamage: 3
                        rotationSpeed: 0.01
                    }
                ]
            },
            {
                enemies: [
                    {
                        type: "small",
                        count: 5,
                        health: 3,
                        speed: 4,
                        fireCooldown: 60,
                        bulletSpeed: 6,
                        bulletDamage: 1,
                        image: 'ufo1.png',
                        isSplitting: false,
                        requiredKills: 5,
                        collisionDamage: 1
                        rotationSpeed: 0.05
                    }
                ]
            },
            {
                enemies: [
                    {
                        type: "large",
                        count: 2,
                        health: 24,
                        speed: 4,
                        fireCooldown: 30,
                        bulletSpeed: 8,
                        bulletDamage: 2,
                        image: 'ufo3.png',
                        isSplitting: false,
                        requiredKills: 2,
                        collisionDamage: 4
                        rotationSpeed: 0.02
                    }
                ]
            }
        ]
    },
    {
        id: 2,
        name: "Keskitaso",
        description: "Haastavampaa toimintaa!",
        waves: [
            {
                enemies: [
                    {
                        type: "medium",
                        count: 3,
                        health: 8,
                        speed: 4,
                        fireCooldown: 80,
                        bulletSpeed: 5,
                        bulletDamage: 1,
                        image: 'ufo2.png',
                        isSplitting: false,
                        requiredKills: 3,
                        collisionDamage: 2
                        rotationSpeed: 0
                    }
                ]
            },
            {
                enemies: [
                    {
                        type: "large",
                        count: 2,
                        health: 20,
                        speed: 3,
                        fireCooldown: 60,
                        bulletSpeed: 6,
                        bulletDamage: 1,
                        image: 'ufo3.png',
                        isSplitting: false,
                        requiredKills: 2,
                        collisionDamage: 3
                        rotationSpeed: 0.02
                    }
                ]
            },
            {
                enemies: [
                    {
                        type: "xlarge",
                        count: 1,
                        health: 15,
                        speed: 2,
                        fireCooldown: 100,
                        bulletSpeed: 8,
                        bulletDamage: 2,
                        image: 'ufo5.png',
                        isSplitting: true,
                        requiredKills: 2,
                        collisionDamage: 3
                        rotationSpeed: 0.02
                    },
                    {
                        type: "small",
                        count: 3,
                        health: 4,
                        speed: 5,
                        fireCooldown: 50,
                        bulletSpeed: 7,
                        bulletDamage: 1,
                        image: 'ufo1.png',
                        isSplitting: false,
                        requiredKills: 3,
                        collisionDamage: 1
                        rotationSpeed: 0.09
                    }
                ]
            },
            {
                enemies: [
                    {
                        type: "medium",
                        count: 4,
                        health: 10,
                        speed: 4,
                        fireCooldown: 70,
                        bulletSpeed: 6,
                        bulletDamage: 1,
                        image: 'ufo4.png',
                        isSplitting: false,
                        requiredKills: 4,
                        collisionDamage: 2
                        rotationSpeed: 0.05
                    }
                ]
            },
            {
                enemies: [
                    {
                        type: "large",
                        count: 3,
                        health: 25,
                        speed: 4,
                        fireCooldown: 40,
                        bulletSpeed: 7,
                        bulletDamage: 2,
                        image: 'ufo3.png',
                        isSplitting: false,
                        requiredKills: 3,
                        collisionDamage: 4
                        rotationSpeed: 0.02
                    }
                ]
            }
        ]
    }
];

let pos1 = 0, pos2 = 0, pos3 = 0;

function animateParallax() {
    pos1 -= 0.05; // kaukaisin (hitaasti)
    pos2 -= 0.15; // keskitason
    pos3 -= 0.35;  // l√§hin (nopein)

    document.getElementById('backgroundLayer1').style.backgroundPosition = `${pos1}px 0`;
    document.getElementById('backgroundLayer2').style.backgroundPosition = `${pos2}px 0`;
    document.getElementById('backgroundLayer3').style.backgroundPosition = `${pos3}px 0`;

    requestAnimationFrame(animateParallax);
}

animateParallax();

        // DOM-elementit
        const startScreen = document.getElementById('startScreen');
        const gameContainer = document.getElementById('gameContainer');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const levelButtonsContainer = document.getElementById('levelButtons');
        const energyFill = document.getElementById('energyFill');
        const waveInfo = document.getElementById('waveInfo');
        const livesContainer = document.getElementById('livesContainer');

        let lastPressedCombo = '';
        let allKeysReleased = true;
        let releaseTimeout = null;
        let previousPressedKeys = new Set();
        let releasedKeysLog = [];
        let lastKeyReleaseTime = 0;

        // Kuvat
        const playerImage = new Image();
        playerImage.src = 'alus.png';

        const bulletImage = new Image();
        bulletImage.src = 'rockets_PNG13272.png';

        const enemyBulletImage = new Image();
        enemyBulletImage.src = 'boss_shot.png';

        const meteorImage = new Image();
        meteorImage.src = 'meteor.png';

        const powerupImage = new Image();
        powerupImage.src = 'ammus_50.png';

        // Pelitilamuuttujat
        let player;
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let meteors = [];
        let powerups = [];
        let gameRunning = true;
        let currentLevel = 1;
        let currentWave = 0;
        let levelCompleted = false;
        let isAnimating = false;
        let animationFrameId = null;
        let meteorSpawnCounter = 0;
        let nextMeteorSpawn = 0;
        let powerupSpawnCounter = 0;
        let bulletDamageMultiplier = 1;
        let bulletSizeMultiplier = 1;
        let powerupCollected = false;
        
        // Nuolin√§pp√§inten seuranta
        const pressedKeys = new Set();
        const keyNames = {
            ArrowUp: "‚Üë",
            ArrowDown: "‚Üì",
            ArrowLeft: "‚Üê",
            ArrowRight: "‚Üí",
            " ": " "
        };

        // Canvasin koon asetus
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Laskee objektin koon
        function calculateSize(baseSize) {
            const baseWidth = 1920;
            const baseHeight = 1080;
            const scale = Math.min(window.innerWidth / baseWidth, window.innerHeight / baseHeight) * 0.8;
            
            return {
                width: baseSize.width * scale,
                height: baseSize.height * scale
            };
        }

        // P√§ivit√§ energiapalkki
        function updateEnergyBar() {
            const percentage = (player.energy / GAME_CONFIG.playerEnergy) * 100;
            energyFill.style.width = `${percentage}%`;
            
            if (percentage > 60) {
                energyFill.style.backgroundColor = '#00ff00';
            } else if (percentage > 30) {
                energyFill.style.backgroundColor = '#ffff00';
            } else {
                energyFill.style.backgroundColor = '#ff0000';
            }
        }

        // P√§ivit√§ el√§m√§t
        function updateLives() {
            livesContainer.innerHTML = '';
            for (let i = 0; i < player.lives; i++) {
                const life = document.createElement('div');
                life.className = 'life';
                livesContainer.appendChild(life);
            }
        }

        // P√§ivit√§ aaltotiedot
        function updateWaveInfo() {
            waveInfo.textContent = `Aalto: ${currentWave + 1}/${GAME_CONFIG.wavesPerLevel}`;
        }

        function getDirectionFromKeySet(keySet) {
            let dx = 0;
            let dy = 0;
            if (keySet.has('ArrowUp')) dy -= 1;
            if (keySet.has('ArrowDown')) dy += 1;
            if (keySet.has('ArrowLeft')) dx -= 1;
            if (keySet.has('ArrowRight')) dx += 1;
            return { x: dx, y: dy };
        }

        // Pelioliot
        class GameObject {
            constructor(image, x, y, width, height) {
                this.image = image;
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = 5;
                this.isDestroyed = false;
                this.exploding = false;
                this.explosionFrame = 0;
                this.repulsionForce = 0;
                this.repulsionAngle = 0;
                this.isRepelling = false;
            }

            draw() {
                if (!this.isDestroyed) {
                    if (this.exploding) {
                        ctx.save();
                        ctx.globalAlpha = (this.explosionFrame % 2 === 0) ? 1 : 0.5;
                        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                        ctx.globalAlpha = 1;
                        ctx.restore();
                        this.explosionFrame++;
                        if (this.explosionFrame > 10) {
                            this.isDestroyed = true;
                        }
                    } else {
                        ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                    }
                }
            }

            getEllipse() {
                return {
                    x: this.x + this.width / 2,
                    y: this.y + this.height / 2,
                    radiusX: this.width * GAME_CONFIG.collisionEllipse.widthRatio / 2,
                    radiusY: this.height * GAME_CONFIG.collisionEllipse.heightRatio / 2
                };
            }

            handleRepulsion() {
                if (this.isRepelling) {
                    this.x += this.repulsionForce * Math.cos(this.repulsionAngle);
                    this.y += this.repulsionForce * Math.sin(this.repulsionAngle);
                    this.repulsionForce *= 0.85;
                    
                    // Rajaa objektin kent√§n sis√§lle
                    this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                    this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));
                    
                    if (this.repulsionForce < 0.5) {
                        this.isRepelling = false;
                        this.repulsionForce = 0;
                    }
                    return true;
                }
                return false;
            }
        }

        class PowerUp extends GameObject {
            constructor(image, x, y, width, height, speed) {
                super(image, x, y, width, height);
                this.speed = speed * (window.innerWidth / 1920);
            }

            move() {
                if (isAnimating) return;
                this.x -= this.speed;
                if (this.x + this.width < 0) {
                    this.isDestroyed = true;
                }
            }
        }

        class Player extends GameObject {
            constructor(image, x, y, width, height) {
                super(image, x, y, width, height);
                this.maxSpeed = GAME_CONFIG.playerSpeed * (window.innerWidth / 1920);
                this.acceleration = this.maxSpeed * 0.1;
                this.deceleration = this.maxSpeed * 0.15;
                this.velocityX = 0;
                this.velocityY = 0;
                this.targetVelocityX = 0;
                this.targetVelocityY = 0;
                this.canShoot = true;
                this.energy = GAME_CONFIG.playerEnergy;
                this.lives = GAME_CONFIG.playerLives;
                this.collisionCooldown = 0;
                this.respawnCooldown = 0;
                this.isRespawning = false;
                this.direction = { x: 1, y: 0 };
                this.rotation = 0;
                this.targetRotation = 0;
                this.rotationSpeed = 0.2;
                this.lastRotation = 0;
            }

move() {
    if (isAnimating) return;
    if (this.handleRepulsion()) return;

    if (this.collisionCooldown > 0) {
        this.collisionCooldown--;
    }

    // --- N√§pp√§insy√∂tteiden tulkinta ---
    let inputX = 0;
    let inputY = 0;

    if (pressedKeys.has('ArrowLeft')) inputX -= 1;
    if (pressedKeys.has('ArrowRight')) inputX += 1;
    if (pressedKeys.has('ArrowUp')) inputY -= 1;
    if (pressedKeys.has('ArrowDown')) inputY += 1;

    // Normalisoi liikesuunta diagonaaleissa
    if (inputX !== 0 || inputY !== 0) {
        const length = Math.hypot(inputX, inputY);
        inputX /= length;
        inputY /= length;
    }

    // --- Liikkeen pehmennys ja kitka ---
    const accelerationFactor = 0.4; // Kiihdytysvoima
    const directionSmoothing = 0.15; // Pehmennys suunnanvaihdoksissa
    const friction = 0.05; // Kitka

    const targetVX = inputX * this.maxSpeed;
    const targetVY = inputY * this.maxSpeed;

    // Pehme√§ suunnanvaihdos
    this.velocityX += (targetVX - this.velocityX) * (this.acceleration * directionSmoothing);
    this.velocityY += (targetVY - this.velocityY) * (this.acceleration * directionSmoothing);

    // Kitka jos ei paineta mit√§√§n
    if (inputX === 0) this.velocityX *= 1 - friction;
    if (inputY === 0) this.velocityY *= 1 - friction;

    // Liikkeen nollaus jos l√§hes paikallaan
    if (Math.abs(this.velocityX) < 0.01) this.velocityX = 0;
    if (Math.abs(this.velocityY) < 0.01) this.velocityY = 0;

    // --- Sijainnin p√§ivitys ---
    this.x += this.velocityX;
    this.y += this.velocityY;

    this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
    this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));

    // --- Suunnan ja py√∂rimisen laskenta ---
    let desiredRotation = this.rotation;
    const moving = Math.abs(this.velocityX) > 0.01 || Math.abs(this.velocityY) > 0.01;

    if (moving) {
        desiredRotation = Math.atan2(this.velocityY, this.velocityX);
        this.lastRotation = desiredRotation;
    } else {
        const now = performance.now();
        if (
            releasedKeysLog.length >= 2 &&
            Math.abs(releasedKeysLog[releasedKeysLog.length - 1].time - releasedKeysLog[releasedKeysLog.length - 2].time) <= 50
        ) {
            const keySet = new Set(releasedKeysLog.slice(-2).map(entry => entry.key));
            const dir = getDirectionFromKeySet(keySet);
            if (dir.x !== 0 || dir.y !== 0) {
                desiredRotation = Math.atan2(dir.y, dir.x);
                this.lastRotation = desiredRotation;
            }
        } else {
            desiredRotation = this.lastRotation ?? this.rotation;
        }
    }

    // --- Py√∂riminen pehme√§sti haluttuun suuntaan ---
    let angleDiff = desiredRotation - this.rotation;
    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

    const rotationSpeed = 0.07; // Pehme√§ py√∂r√§hdys
    if (Math.abs(angleDiff) < 0.01) {
        this.rotation = desiredRotation;
    } else {
        this.rotation += angleDiff * rotationSpeed;
    }

    // --- Suuntavektori ampumista varten ---
    this.direction = {
        x: Math.cos(this.rotation),
        y: Math.sin(this.rotation)
    };
}




            shoot() {
                if (this.canShoot && !isAnimating && !this.isRespawning) {
                    const bulletSize = calculateSize({width: 20 * bulletSizeMultiplier, height: 10 * bulletSizeMultiplier});
                    const centerX = this.x + this.width / 2;
                    const centerY = this.y + this.height / 2;
                    
                    const bulletX = centerX + this.direction.x * this.width/2;
                    const bulletY = centerY + this.direction.y * this.height/2;
                    
                    const bulletVelocityX = this.direction.x * GAME_CONFIG.bulletSpeed * (window.innerWidth / 1920) + this.velocityX * 0.5;
                    const bulletVelocityY = this.direction.y * GAME_CONFIG.bulletSpeed * (window.innerWidth / 1920) + this.velocityY * 0.5;
                    
                    bullets.push(new Bullet(
                        bulletImage, 
                        bulletX - bulletSize.width/2, 
                        bulletY - bulletSize.height/2, 
                        bulletSize.width, 
                        bulletSize.height,
                        bulletVelocityX,
                        bulletVelocityY,
                        this.rotation,
                        bulletDamageMultiplier
                    ));
                    soundEffects.playerShoot.play();
                    this.canShoot = false;
                }
            }

            draw() {
                if (this.isRespawning) {
                    this.respawnCooldown--;
                    if (this.respawnCooldown <= 0) {
                        this.isRespawning = false;
                    }
                    
                    if (Math.floor(this.respawnCooldown / 10) % 2 === 0) {
                        ctx.save();
                        ctx.globalAlpha = 0.5;
                        this.drawRotated();
                        ctx.restore();
                    }
                } else {
                    this.drawRotated();
                }
            }
            
            drawRotated() {
                if (this.isDestroyed) return;
                
                ctx.save();
                // Siirr√§ origo aluksen keskelle
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                // Kierr√§ alus
                ctx.rotate(this.rotation);
                // Piirr√§ alus keskipisteest√§
                ctx.drawImage(this.image, -this.width / 2, -this.height / 2, this.width, this.height);
                ctx.restore();
            }

            takeDamage(damage) {
                if (this.isRespawning) return;
                
                this.energy -= damage;
                updateEnergyBar();
                
                if (this.energy <= 0) {
                    this.loseLife();
                }
            }
            
            loseLife() {
                this.lives--;
                updateLives();
                
                if (this.lives <= 0) {
                    this.energy = 0;
                    this.exploding = true;
                    this.explosionFrame = 0;
                    showGameOver();
                } else {
                    this.isRespawning = true;
                    this.respawnCooldown = 120;
                    this.energy = GAME_CONFIG.playerEnergy;
                    updateEnergyBar();
                    
                    this.x = canvas.width / 2 - this.width / 2;
                    this.y = canvas.height / 2 - this.height / 2;
                    this.velocityX = 0;
                    this.velocityY = 0;
                    this.targetVelocityX = 0;
                    this.targetVelocityY = 0;
                    this.direction = { x: 1, y: 0 };
                    this.rotation = 0;
                    this.targetRotation = 0;
                }
            }
        }

        class Enemy extends GameObject {
            constructor(image, x, y, width, height, health, speed, isSplitting, fireCooldown, bulletSpeed, bulletDamage, collisionDamage, rotationSpeed) {
                super(image, x, y, width, height);
                this.health = health;
                this.baseHealth = health;
                this.baseSpeed = speed * (window.innerWidth / 1920);
                this.speed = this.baseSpeed;
                this.fireCooldown = fireCooldown;
                this.bulletSpeed = bulletSpeed * (window.innerWidth / 1920);
                this.fireCounter = 0;
                this.isSplitting = isSplitting;
                this.bulletDamage = Math.max(1, Math.min(bulletDamage, 2));
                this.collisionDamage = Math.max(1, Math.min(collisionDamage, 4));
                this.collisionCooldown = 0;
                this.directionChangeCounter = 0;
                this.currentDirection = Math.random() * Math.PI * 2;
                this.targetDirection = this.currentDirection;
                this.directionChangeInterval = Math.floor(Math.random() * 60) + 30;
                this.wobbleAmount = Math.random() * 0.2 + 0.1;
                this.wobbleSpeed = Math.random() * 0.05 + 0.02;
                this.wobbleCounter = 0;
                this.rotation = Math.random() * Math.PI * 2; // Satunnainen aloituskulma
                this.rotationSpeed = (Math.random() - 0.5) * 0.02; // Satunnainen py√∂rimisnopeus
            }

            follow(player) {
                if (isAnimating || player.isRespawning) return;
                
                if (this.handleRepulsion()) {
                    return;
                }

                this.rotation += this.rotationSpeed;
                
                if (this.collisionCooldown > 0) {
                    this.collisionCooldown--;
                    return;
                }
                
                this.directionChangeCounter++;
                if (this.directionChangeCounter >= this.directionChangeInterval) {
                    this.directionChangeCounter = 0;
                    this.directionChangeInterval = Math.floor(Math.random() * 60) + 30;
                    
                    const playerCenterX = player.x + player.width / 2;
                    const playerCenterY = player.y + player.height / 2;
                    const enemyCenterX = this.x + this.width / 2;
                    const enemyCenterY = this.y + this.height / 2;
                    
                    const deltaX = playerCenterX - enemyCenterX;
                    const deltaY = playerCenterY - enemyCenterY;
                    const targetAngle = Math.atan2(deltaY, deltaX);
                    
                    const angleVariation = (Math.random() - 0.5) * Math.PI / 2;
                    this.targetDirection = targetAngle + angleVariation;
                }
                
                this.wobbleCounter += this.wobbleSpeed;
                const wobbleOffset = Math.sin(this.wobbleCounter) * this.wobbleAmount;
                
                const angleDifference = this.targetDirection - this.currentDirection;
                this.currentDirection += angleDifference * 0.1;
                
                this.x += this.speed * Math.cos(this.currentDirection + wobbleOffset);
                this.y += this.speed * Math.sin(this.currentDirection + wobbleOffset);
                
                this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));
            }

            handleCollision(player) {
                if (this.collisionCooldown > 0 || player.collisionCooldown > 0 || player.isRespawning) {
                    return;
                }

                soundEffects.collision.play();

                const dx = (this.x + this.width/2) - (player.x + player.width/2);
                const dy = (this.y + this.height/2) - (player.y + player.height/2);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const nx = dx / distance;
                const ny = dy / distance;

                player.repulsionForce = this.baseSpeed * 3;
                player.repulsionAngle = Math.atan2(ny, nx) + Math.PI;
                player.isRepelling = true;
                player.collisionCooldown = 10;

                this.repulsionForce = this.baseSpeed * 4;
                this.repulsionAngle = Math.atan2(ny, nx);
                this.isRepelling = true;
                this.collisionCooldown = 10;

                player.takeDamage(this.collisionDamage);
                
                if (this.health <= 1) {
                    if (this.isSplitting) {
                        this.split();
                    } else {
                        this.takeDamage();
                    }
                }
            }

            takeDamage() {
                if (this.exploding) return;
                this.health -= 1;
                if (this.health <= 0) {
                    this.destroyEnemy();
                }
            }

            destroyEnemy() {
                if (this.isSplitting) {
                    soundEffects.ufoSplit.play();
                    this.split();
                } else {
                    soundEffects.enemyExplosion.play();
                    this.exploding = true;
                    checkWaveCompletion();
                }
            }

            split() {
                this.isDestroyed = true;
                const originalType = this.type || 'medium';
                
                let newSize;
                if (originalType === 'xlarge') {
                    newSize = calculateSize(GAME_CONFIG.enemySizes.large);
                } else if (originalType === 'large') {
                    newSize = calculateSize(GAME_CONFIG.enemySizes.medium);
                } else if (originalType === 'medium') {
                    newSize = calculateSize(GAME_CONFIG.enemySizes.small);
                } else {
                    newSize = calculateSize(GAME_CONFIG.enemySizes.small);
                }
                
                const topUfoY = this.y - newSize.height / 2;
                const bottomUfoY = this.y + this.height - newSize.height / 2;

                const baseHealth = this.baseHealth || this.health;
                const newHealth = Math.max(1, Math.ceil(baseHealth / 2));
                
                enemies.push(new Enemy(
                    this.image, 
                    this.x + (this.width - newSize.width) / 2,
                    topUfoY,
                    newSize.width, 
                    newSize.height, 
                    newHealth,
                    this.baseSpeed / (window.innerWidth / 1920) + 1,
                    false,
                    this.fireCooldown,
                    this.bulletSpeed,
                    this.bulletDamage,
                    Math.max(1, Math.floor(this.collisionDamage / 2))
                ));
                
                enemies.push(new Enemy(
                    this.image, 
                    this.x + (this.width - newSize.width) / 2,
                    bottomUfoY,
                    newSize.width, 
                    newSize.height, 
                    newHealth,
                    this.baseSpeed / (window.innerWidth / 1920) + 1,
                    false,
                    this.fireCooldown,
                    this.bulletSpeed,
                    this.bulletDamage,
                    Math.max(1, Math.floor(this.collisionDamage / 2))
                ));
            }

            fire(player) {
                if (this.fireCounter <= 0 && !isAnimating && !player.isRespawning) {
                    const bulletSize = calculateSize({width: 15, height: 15});
                    const bulletX = this.x + this.width / 2;
                    const bulletY = this.y + this.height / 2;
                    const angle = Math.atan2(player.y + player.height/2 - bulletY, player.x + player.width/2 - bulletX);

                    enemyBullets.push(new EnemyBullet(
                        enemyBulletImage, 
                        bulletX, 
                        bulletY, 
                        bulletSize.width, 
                        bulletSize.height, 
                        angle, 
                        this.bulletSpeed,
                        this.bulletDamage
                    ));
                    soundEffects.enemyShoot.play();
                    this.fireCounter = this.fireCooldown;
                } else {
                    this.fireCounter--;
                }
            }
        }

        class Bullet extends GameObject {
            constructor(image, x, y, width, height, velocityX, velocityY, angle, damageMultiplier = 1) {
                super(image, x, y, width, height);
                this.velocityX = velocityX;
                this.velocityY = velocityY;
                this.angle = angle || 0;
                this.damageMultiplier = damageMultiplier;
            }

            move() {
                if (isAnimating) return;
                this.x += this.velocityX;
                this.y += this.velocityY;
                if (this.x > canvas.width || this.x < 0 || this.y > canvas.height || this.y < 0) {
                    this.isDestroyed = true;
                }
            }
            
    draw() {
        if (!this.isDestroyed) {
            ctx.save();
            ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
            ctx.rotate(this.rotation);
            
            if (this.exploding) {
                ctx.globalAlpha = (this.explosionFrame % 2 === 0) ? 1 : 0.5;
                ctx.drawImage(this.image, -this.width / 2, -this.height / 2, this.width, this.height);
                ctx.globalAlpha = 1;
            } else {
                ctx.drawImage(this.image, -this.width / 2, -this.height / 2, this.width, this.height);
            }
            
            ctx.restore();
        }
    }
        }

        class EnemyBullet extends GameObject {
            constructor(image, x, y, width, height, angle, speed, damage) {
                super(image, x, y, width, height);
                this.angle = angle;
                this.speed = speed;
                this.damage = Math.min(damage, 2);
            }

            move() {
                if (isAnimating) return;
                this.x += this.speed * Math.cos(this.angle);
                this.y += this.speed * Math.sin(this.angle);
                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
                    this.isDestroyed = true;
                }
            }
        }

        class Meteor extends GameObject {
            constructor(image, x, y, width, height, speed) {
                super(image, x, y, width, height);
                this.speed = speed;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
            }

            move() {
                if (isAnimating) return;
                this.x -= this.speed;
                this.rotation += this.rotationSpeed;
                
                if (this.x + this.width < 0) {
                    this.isDestroyed = true;
                }
            }

            draw() {
                if (!this.isDestroyed) {
                    ctx.save();
                    ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.rotate(this.rotation);
                    ctx.drawImage(this.image, -this.width / 2, -this.height / 2, this.width, this.height);
                    ctx.restore();
                }
            }
        }

        // Luo uusi meteoriitti
        function spawnMeteor() {
            const sizeValue = Math.floor(Math.random() * (GAME_CONFIG.meteor.maxSize - GAME_CONFIG.meteor.minSize + 1)) + GAME_CONFIG.meteor.minSize;
            const size = calculateSize({width: sizeValue, height: sizeValue});
            const y = Math.random() * (canvas.height - size.height);
            const speed = GAME_CONFIG.meteor.minSpeed + Math.random() * (GAME_CONFIG.meteor.maxSpeed - GAME_CONFIG.meteor.minSpeed);
            const meteor = new Meteor(
                meteorImage,
                canvas.width,
                y,
                size.width,
                size.height,
                speed * (window.innerWidth / 1920)
            );
            meteors.push(meteor);
            soundEffects.meteorSound.play();
        }

        // Luo uusi power-up
        function spawnPowerUp() {
            if (powerupCollected) return; // Don't spawn if already collected
            
            const size = calculateSize(GAME_CONFIG.powerup.size);
            const y = Math.random() * (canvas.height - size.height);
            const powerup = new PowerUp(
                powerupImage,
                canvas.width,
                y,
                size.width,
                size.height,
                GAME_CONFIG.powerup.speed
            );
            powerups.push(powerup);
            soundEffects.powerup.play();
        }

        // Tason alustus
        function initializeLevel(levelId) {
            const level = LEVELS.find(l => l.id === levelId);
            if (!level) return;

            currentLevel = levelId;
            currentWave = 0;
            levelCompleted = false;
            isAnimating = false;
            meteors = [];
            powerups = [];
            meteorSpawnCounter = 0;
            nextMeteorSpawn = Math.floor(Math.random() * (GAME_CONFIG.meteor.spawnInterval.max - GAME_CONFIG.meteor.spawnInterval.min + 1)) + GAME_CONFIG.meteor.spawnInterval.min;
            powerupSpawnCounter = 0;
            bulletDamageMultiplier = 1;
            bulletSizeMultiplier = 1;
            powerupCollected = false; // Reset collected flag for new level

            const playerSize = calculateSize(GAME_CONFIG.playerSize);
            player = new Player(
                playerImage, 
                canvas.width / 2 - playerSize.width / 2,
                canvas.height / 2 - playerSize.height / 2, 
                playerSize.width, 
                playerSize.height
            );
            updateEnergyBar();
            updateLives();
            updateWaveInfo();

            startNextWave();
        }

        // Aloita seuraava aalto
        function startNextWave() {
            const level = LEVELS.find(l => l.id === currentLevel);
            if (!level || currentWave >= level.waves.length) {
                showLevelCompleted();
                return;
            }

            enemies = [];
            const waveConfig = level.waves[currentWave];
            
            waveConfig.enemies.forEach(enemyConfig => {
                for (let i = 0; i < enemyConfig.count; i++) {
                    const size = calculateSize(GAME_CONFIG.enemySizes[enemyConfig.type]);
                    const x = canvas.width - size.width - 50 - (i * 50);
                    const y = Math.random() * (canvas.height - size.height);
                    
                    const enemy = new Enemy(
                        new Image(), 
                        x,
                        y,
                        size.width,
                        size.height,
                        enemyConfig.health,
                        enemyConfig.speed,
                        enemyConfig.isSplitting,
                        enemyConfig.fireCooldown,
                        enemyConfig.bulletSpeed,
                        enemyConfig.bulletDamage,
                        enemyConfig.collisionDamage
                        enemyConfig.rotationSpeed
                    );
                    enemy.type = enemyConfig.type;
                    enemy.image.src = enemyConfig.image;
                    enemies.push(enemy);
                }
            });

            bullets = [];
            enemyBullets = [];
            updateWaveInfo();
        }

        function checkWaveCompletion() {
            const level = LEVELS.find(l => l.id === currentLevel);
            if (!level || currentWave >= level.waves.length) return;

            const allEnemiesDestroyed = enemies.every(enemy => enemy.isDestroyed);
            
            if (!allEnemiesDestroyed) return;

            if (currentWave === level.waves.length - 1) {
                showLevelCompleted();
            } else {
                currentWave++;
                startNextWave();
            }
        }

        function checkEllipseCollision(obj1, obj2) {
            const ellipse1 = obj1.getEllipse();
            const ellipse2 = obj2.getEllipse();
            
            const dx = ellipse2.x - ellipse1.x;
            const dy = ellipse2.y - ellipse1.y;
            
            const distanceSquared = (dx * dx) / (ellipse1.radiusX + ellipse2.radiusX) ** 2 + 
                                   (dy * dy) / (ellipse1.radiusY + ellipse2.radiusY) ** 2;
            
            return distanceSquared <= 1;
        }

        function update() {
            if (!gameRunning) return;

            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                updateGameState();                
                drawAllObjects();                
                checkWaveCompletion();
                
            } catch (e) {
                console.error("P√§ivitysvirhe:", e);
                resetGameState();
            }

            animationFrameId = requestAnimationFrame(update);
        }

        function updateGameState() {
            // P√§ivit√§ meteoriittien spawnaus
            meteorSpawnCounter++;
            if (meteorSpawnCounter >= nextMeteorSpawn) {
                spawnMeteor();
                meteorSpawnCounter = 0;
                nextMeteorSpawn = Math.floor(Math.random() * (GAME_CONFIG.meteor.spawnInterval.max - GAME_CONFIG.meteor.spawnInterval.min + 1)) + GAME_CONFIG.meteor.spawnInterval.min;
            }

            // P√§ivit√§ power-up spawnaus vain jos ei ole viel√§ ker√§tty
            if (!powerupCollected) {
                powerupSpawnCounter++;
                if (powerupSpawnCounter >= GAME_CONFIG.powerup.spawnInterval && 
                    powerups.length === 0 && 
                    Math.random() < GAME_CONFIG.powerup.spawnChance) {
                    spawnPowerUp();
                    powerupSpawnCounter = 0;
                }
            }

            // P√§ivit√§ pelaaja
            player.move();
            
            // P√§ivit√§ ammukset
            updateBullets();
            
            // P√§ivit√§ viholliset
            updateEnemies();
            
            // P√§ivit√§ vihollisten ammukset
            updateEnemyBullets();
            
            // P√§ivit√§ meteoriitit
            updateMeteors();
            
            // P√§ivit√§ power-upit
            updatePowerups();
        }

        function updateBullets() {
            bullets.forEach(bullet => {
                bullet.move();
            });

            bullets = bullets.filter(bullet => {
                if (bullet.isDestroyed) return false;
                
                let hit = false;
                enemies.forEach(enemy => {
                    if (!enemy.isDestroyed && checkEllipseCollision(bullet, enemy)) {
                        bullet.isDestroyed = true;
                        enemy.takeDamage(bullet.damageMultiplier);
                        hit = true;
                    }
                });
                
                return !hit;
            });
        }

        function updateEnemies() {
            enemies.forEach(enemy => {
                if (enemy.isDestroyed) return;
                
                enemy.follow(player);
                enemy.fire(player);
                
                if (checkEllipseCollision(player, enemy)) {
                    enemy.handleCollision(player);
                }
            });
        }

        function updateEnemyBullets() {
            enemyBullets.forEach(bullet => {
                if (bullet.isDestroyed) return;
                
                bullet.move();
                
                if (checkEllipseCollision(player, bullet)) {
                    player.takeDamage(bullet.damage || 1);
                    bullet.isDestroyed = true;
                }
            });
        }

        function updateMeteors() {
            meteors.forEach(meteor => {
                meteor.move();
                
                if (!player.isRespawning && checkEllipseCollision(player, meteor)) {
                    soundEffects.playerExplosion.play();
                    player.loseLife();
                    meteor.isDestroyed = true;
                }
            });

            meteors = meteors.filter(meteor => !meteor.isDestroyed);
        }

        function updatePowerups() {
            powerups.forEach(powerup => {
                if (powerup.isDestroyed) return;
                
                powerup.move();
                
                if (checkEllipseCollision(player, powerup)) {
                    soundEffects.powerup.play();
                    bulletDamageMultiplier = 1.5;
                    bulletSizeMultiplier = 1.5;
                    powerup.isDestroyed = true;
                    powerupCollected = true; // Mark as collected
                }
            });

            powerups = powerups.filter(powerup => !powerup.isDestroyed);
        }

        function drawAllObjects() {
            // Piirr√§ taustaelementit ensin
            meteors.forEach(meteor => meteor.draw());
            powerups.forEach(powerup => powerup.draw());
            bullets.forEach(bullet => bullet.draw());
            enemyBullets.forEach(bullet => bullet.draw());
            
            // Piirr√§ viholliset
            enemies.forEach(enemy => {
                if (!enemy.isDestroyed) enemy.draw();
            });
            
            // Piirr√§ pelaaja viimeisen√§
            player.draw();
        }

        function resetGameState() {
            // Palauta pelaaja turvalliseen sijaintiin
            if (player) {
                player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));
                player.y = Math.max(0, Math.min(canvas.height - player.height, player.y));
            }
        }

        function showGameOver() {
            soundEffects.playerExplosion.play();
            soundEffects.backgroundMusic.pause();
            document.getElementById('gameOver').style.display = 'block';
            gameRunning = false;
        }

        function hideGameOver() {
            document.getElementById('gameOver').style.display = 'none';
            gameRunning = true;
        }

        function showLevelCompleted() {
            if (levelCompleted) return;
            levelCompleted = true;
            document.getElementById('levelCompleted').style.display = 'block';
            gameRunning = false;
        }

        function hideLevelCompleted() {
            document.getElementById('levelCompleted').style.display = 'none';
            gameRunning = true;
        }

        function restartGame() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            initializeLevel(currentLevel);
            hideGameOver();
            hideLevelCompleted();
            soundEffects.backgroundMusic.currentTime = 0;
            soundEffects.backgroundMusic.play();
            update();
        }

        function nextLevel() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            const nextLevel = currentLevel + 1;
            if (nextLevel <= LEVELS.length) {
                currentLevel = nextLevel;
                initializeLevel(currentLevel);
                hideLevelCompleted();
                soundEffects.backgroundMusic.currentTime = 0;
                soundEffects.backgroundMusic.play();
                update();
            } else {
                document.getElementById('levelCompleted').innerHTML = `
                    <h1>Kaikki tasot suoritettu!</h1>
                    <p>Onneksi olkoon, voitit pelin!</p>
                    <button onclick="returnToMenu()">P√§√§valikkoon</button>
                `;
            }
        }

        function returnToMenu() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            gameContainer.style.display = 'none';
            startScreen.style.display = 'block';
            hideLevelCompleted();
            soundEffects.backgroundMusic.pause();
        }

        function startGame(levelId) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            currentLevel = levelId;
            startScreen.style.display = 'none';
            gameContainer.style.display = 'block';
            resizeCanvas();
            initializeLevel(levelId);
            soundEffects.backgroundMusic.play();
            update();
        }

        function initializeLevelButtons() {
            LEVELS.forEach(level => {
                const button = document.createElement('button');
                button.textContent = `Taso ${level.id}: ${level.name}`;
                button.onclick = () => startGame(level.id);
                button.title = level.description;
                levelButtonsContainer.appendChild(button);
            });
        }

        // iOS √§√§nien k√§ytt√∂√∂notto
        function enableAudio() {
            const dummyAudio = new Audio();
            dummyAudio.volume = 0;
            dummyAudio.play().then(() => {
                dummyAudio.pause();
                dummyAudio.currentTime = 0;
            });
        }

        // Nuolin√§pp√§inten k√§sittely
        function handleKeyDown(e) {
            if (keyNames[e.key]) {
                pressedKeys.add(e.key);
                allKeysReleased = false;

                // Tallenna kopio nykyisest√§ n√§pp√§intilasta
                previousPressedKeys = new Set(pressedKeys);

                // Peru viive jos painetaan lis√§√§
                if (releaseTimeout) {
                    clearTimeout(releaseTimeout);
                    releaseTimeout = null;
                }

                if (e.key === ' ' && gameRunning) {
                    player.shoot();
                }
            }
        }

        function handleKeyUp(e) {
            if (keyNames[e.key]) {
                pressedKeys.delete(e.key);

                if (e.key === ' ') {
                    player.canShoot = true;
                }

                // Tallenna vapautettu n√§pp√§in ja aikaleima
                const now = performance.now();
                releasedKeysLog.push({ key: e.key, time: now });
                lastKeyReleaseTime = now;

                // Pid√§ vain kaksi viimeisint√§ vapautusta
                if (releasedKeysLog.length > 2) {
                    releasedKeysLog.shift();
                }

                if (pressedKeys.size === 0 && !allKeysReleased) {
                    allKeysReleased = true;

                    releaseTimeout = setTimeout(() => {
                        lastPressedCombo = Array.from(previousPressedKeys).sort().join(' + ');
                    }, 50);
                }
            }
        }

        // Alustus
        window.addEventListener('load', () => {
            initializeLevelButtons();
            enableAudio();
            resizeCanvas();
            
            document.body.addEventListener('click', enableAudio, { once: true });
            
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
        });

        window.addEventListener('resize', () => {
            resizeCanvas();
        });
    </script>
</body>
</html>
